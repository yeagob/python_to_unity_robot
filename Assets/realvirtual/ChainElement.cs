// realvirtual (R) Framework for Automation Concept Design, Virtual Commissioning and 3D-HMI
// Copyright(c) 2019 realvirtual GmbH - Usage of this source code only allowed based on License conditions see https://realvirtual.io/en/company/license

using UnityEngine;
using NaughtyAttributes;
#if REALVIRTUAL_BURST
using Unity.Mathematics;
#endif

namespace realvirtual
{
    [HelpURL("https://doc.realvirtual.io/components-and-scripts/motion/chain-element")]
    [SelectionBase]
    [RequireComponent(typeof(Rigidbody))]
    //! ChainElement represents individual links, buckets, or carriers in continuous chain transport systems.
    //! This component transforms objects into chain-driven transport elements that move along spline paths,
    //! maintaining proper spacing and orientation while transporting materials. Supports automatic alignment
    //! with chain curvature, physics-based collision handling for material interaction, and synchronization
    //! with drive speeds. Essential for bucket elevators, overhead power-and-free systems, chain conveyors,
    //! and other continuous transport applications in manufacturing and material handling.
    public class ChainElement : realvirtualBehavior, IChainElement
    {
        [Header(("Settings"))] 
        [Tooltip("Aligns the chain element to follow the chain tangent direction while moving")]
        public bool
            AlignWithChain = true; //!< true if the chainelement needs to align with the chain tangent while moving

        [Tooltip("Enable physics-based movement for chain elements with colliders")]
        [InfoBox("💡 Performance Tip: Set to false for maximum Burst optimization (29-33x speedup) if physics interaction is not needed. " +
                 "With true, you still get 19-23x speedup. Enable Burst in Chain component for best performance.",
                 EInfoBoxType.Normal)]
        public bool
            MoveRigidBody =
                true; //!< needs to be set to true if chainelements has colliders which should make parts move physically

        [Tooltip("Additional rotation vector for alignment (local Z points to tangent)")]
        [ShowIf("AlignWithChain")] [InfoBox("Z of object to tangent, AlignVector or AlignObjectZ = up")]
        public Vector3 AlignVector = new Vector3(1, 0, 0); //!< additinal rotation for the alignment

        [Tooltip("Reference object whose forward direction defines the up vector for alignment")]
        [ShowIf("AlignWithChain")] public GameObject AlignObjectLocalZUp;

        [Tooltip("Shows debug visualization (Green = Tangent, Red = Up direction)")]
        [ShowIf("AlignWithChain")] [InfoBox("Debug Green = Tangent, Red = Up")]
        public bool DebugDirections;
        
        [Tooltip("Initial position of the chain element along the chain in mm")]
        public float InitialPosition =0;
        [Tooltip("Position offset relative to the drive position in mm")]
        public float OffsetToDrivePosition = 0;
        
        public Drive ConnectedDrive { get; set; } //!< Drive where the chain is connected to
        public float StartPosition { get; set; } //!< Start position of this chain element

        [Tooltip("Reference to the chain (leave null for auto-generated elements)")]
        [InfoBox("Keep this null, if elements are created automatically on Start by defined Number in Chain - if not, connect the chain here")]
        public Chain ConnectedChain;
        public Chain Chain { get; set; } //!< Chain where this chainelement belongs to
        public bool UsePath { get; set; }
        [HideInInspector]public bool UseUnitySpline { get; set; }
        public float Position { get; set; } //!< Current position of this chain element
        public float RelativePosition { get; set; } //!< Relative position of this chain element
        [HideInInspector]public bool UseBatchUpdate = false; // Set by Chain during creation
        
        
        private Vector3 _targetpos;
        private Quaternion targetrotation;
        private Vector3 tangentforward;
        private realvirtualController realvirtualcontroller;
        private bool chainnotnull = false;
        private bool alignobjectnotnull = false;
        private bool SplineIsVertical = false;
        private bool connecteddrivenotnull = false;
        private Rigidbody _rigidbody;
        private bool autogenerated = false;
        private float _lastAppliedPosition = float.NaN;

        public void InitPos(float pos)
        {
            pos = pos + OffsetToDrivePosition;
            StartPosition = pos;
            InitialPosition= pos;
            if(!UseUnitySpline)
            {
                if (Chain.chainOrientation == ChainOrientation.Vertical)
                {
                    SplineIsVertical = true;
                }

                if (AlignWithChain)
                {
                    RelativePosition = pos / Chain.Length;
                    var positon = Chain.GetPosition(RelativePosition);
                    transform.position = positon;

                    Quaternion rotation = new Quaternion();
                    var tangent = Chain.GetTangent(RelativePosition);
                    Vector3 align = AlignVector;
                    if (alignobjectnotnull)
                    {
                        align = transform.TransformDirection(AlignObjectLocalZUp.transform.forward);
                    }

                    rotation = Quaternion.LookRotation(tangent, align);
                    if (SplineIsVertical)
                    {
                        if (tangent.z < 0 || (tangent.z == 0 && tangent.x > 0))
                        {
                            rotation = Quaternion.LookRotation(tangent, -align);
                        }
                    }
                    transform.rotation = rotation;
                    if (DebugDirections)
                    {
                        Debug.DrawRay(transform.position, tangent, Color.green, 20);
                        Debug.DrawRay(transform.position, align, Color.red);
                    }
                }
            }
            else
            {
                if (AlignWithChain)
                {
                    RelativePosition = pos / Chain.Length;
                    var positon = Chain.GetPosition(RelativePosition);
                    transform.position = positon;
                    
                    var tangent = Chain.GetTangent(RelativePosition);
                    var updirection = Chain.GetUpDirection(RelativePosition);
                    Quaternion rotation = new Quaternion();
                    rotation = Quaternion.LookRotation(tangent, updirection);
                    transform.rotation = rotation;
                    if (DebugDirections)
                    {
                        Debug.DrawRay(transform.position, tangent, Color.green, 20);
                        Debug.DrawRay(transform.position, updirection, Color.red);
                    }
                }
            }
            autogenerated = true;
        }

        private bool ShouldSkipTransformUpdate(float newPosition)
        {
            if (Chain == null)
                return false;

            float minDelta = Mathf.Max(Chain.ElementUpdateThreshold, 0f);
            if (minDelta <= 0f)
                return false;

            if (float.IsNaN(_lastAppliedPosition))
                return false;

            return Mathf.Abs(newPosition - _lastAppliedPosition) < minDelta;
        }

        public void SetPosition()
        {
            float relevantLength=Chain.Length;
            if (Chain.ScaledOnFixedLength)
            {
                relevantLength = Chain.FixedLength;
            }

            if(Mathf.Abs(Position) > relevantLength)
            {
                Position = Position % relevantLength;
            }
            RelativePosition = (Position < 0 
                                 ? (1 - Mathf.Abs(Position) / relevantLength) 
                                 : (Position / relevantLength));
            
            var positon = Chain.GetPosition(RelativePosition);

            if (MoveRigidBody)
                _rigidbody.MovePosition(positon);
            else
                transform.position = positon;

            _targetpos = transform.position;
            
            if (AlignWithChain)
            {
                Vector3 tangent=Vector3.zero;
                Vector3 align = AlignVector;
                Quaternion rotation = new Quaternion();
                if(!UseUnitySpline)
                {
                    tangent = Chain.GetTangent(RelativePosition);
                    align = AlignVector;
                    if (alignobjectnotnull)
                    {
                        align = transform.TransformDirection(AlignObjectLocalZUp.transform.forward);
                    }

                    rotation = Quaternion.LookRotation(tangent, align);
                    if (SplineIsVertical)
                    {
                        if (tangent.z < 0 || (tangent.z == 0 && tangent.x > 0))
                        {
                            rotation = Quaternion.LookRotation(tangent, -align);
                        }
                    }
                }
                else
                {
                    
                    tangent = Chain.GetTangent(RelativePosition);
                    align = Chain.GetUpDirection(RelativePosition);
                    rotation = Quaternion.LookRotation(tangent, align);
                }
                if (DebugDirections)
                {
                    Debug.DrawRay(transform.position, tangent, Color.green);
                    Debug.DrawRay(transform.position, align, Color.red);
                }

                if (MoveRigidBody)
                    _rigidbody.MoveRotation(rotation);
                else
                    transform.rotation = rotation;
            }
            _lastAppliedPosition = Position;
        }

        public void UpdatePosition(float deltaTime)
        {
            if (!connecteddrivenotnull) return;

            float newPosition = ConnectedDrive.CurrentPosition + StartPosition + OffsetToDrivePosition;
            if (ShouldSkipTransformUpdate(newPosition))
                return;

            Position = newPosition;
            SetPosition();
        }

        private void Start()
        {
            var drive =this.GetComponent<Drive>();
            if (drive != null && drive.Direction == DIRECTION.Virtual)
            {
                this.ConnectedDrive = drive;
                connecteddrivenotnull = true;
            }
            _rigidbody = GetComponent<Rigidbody>();
            if (_rigidbody == null)
            {
                _rigidbody = gameObject.AddComponent<Rigidbody>();
                Debug.Log("ChainElement: Rigidbody is missing, automatically added to " + gameObject.name);
            }

            _rigidbody.isKinematic = true;
            alignobjectnotnull = AlignObjectLocalZUp != null;

            if (ConnectedChain != null)
            {
                Chain = ConnectedChain;
            }
            else
            {
                ConnectedChain = Chain;
            }

            if (Chain != null)
            {
                chainnotnull = true;
                UseUnitySpline = Chain.unitySplineActive;
                // only use chain drive if no own drive is connected
                if(!connecteddrivenotnull)
                    ConnectedDrive = Chain.ConnectedDrive;
                UsePath = Chain.usepath;

                if (Chain.spline != null)
                {
                    Vector3 VectorA = Chain.spline.Anchors[1].Anchor.transform.localPosition -
                                      Chain.spline.Anchors[0].Anchor.transform.localPosition;

                    if (Chain.chainOrientation == ChainOrientation.Vertical)
                    {
                        SplineIsVertical = true;
                    }
                }
                if(InitialPosition!=0)
                {
                    Position = InitialPosition;
                    StartPosition = InitialPosition;
                }
                SetPosition();
            }
            else
                chainnotnull = false;

            if (ConnectedDrive == null && autogenerated)
            {
                Debug.LogError(
                    "No Drive connected to ChainElement, please add a drive to the element itself (for controlling single element) or a drive to the chain (for moving the full chain with one drive)");
            }
            else
            {
                connecteddrivenotnull = ConnectedDrive != null;
            }

            // Only subscribe individually if NOT using batch updates
            if (connecteddrivenotnull && !UseBatchUpdate)
            {
                ConnectedDrive.OnAfterDriveCalculation.AddListener(UpdatePosition);
            }
        }

        private void OnDestroy()
        {
            // Clean up individual subscription if used
            if (ConnectedDrive != null && !UseBatchUpdate)
            {
                ConnectedDrive.OnAfterDriveCalculation.RemoveListener(UpdatePosition);
            }

            // Unregister from Chain's batch update
            if (Chain != null && UseBatchUpdate)
            {
                Chain.UnregisterElement(this);
            }
        }
        public void UpdatePosition(Drive drive)
        {
            if (chainnotnull)
                UpdatePosition(0);
        }

        // New: Called by Chain's managed batch update
        public void UpdatePositionBatch(float position)
        {
            if (ShouldSkipTransformUpdate(position))
                return;

            Position = position;
            SetPosition();
        }

#if REALVIRTUAL_BURST
        // New: Called by Chain after Burst job completes
        public void ApplyBurstResult(float3 position, quaternion rotation)
        {
            // Convert from Unity.Mathematics types to UnityEngine types
            Vector3 pos = new Vector3(position.x, position.y, position.z);
            Quaternion rot = new Quaternion(rotation.value.x, rotation.value.y, rotation.value.z, rotation.value.w);

            // Apply ElementUpdateThreshold check for consistency with managed path
            // Note: Position check is based on world position, not chain position
            if (Chain != null && Chain.ElementUpdateThreshold > 0f)
            {
                if (!float.IsNaN(_lastAppliedPosition))
                {
                    float delta = Vector3.Distance(pos, _targetpos);
                    if (delta < Chain.ElementUpdateThreshold)
                        return; // Skip update if movement is below threshold
                }
            }

            if (MoveRigidBody)
            {
                _rigidbody.MovePosition(pos);
                _rigidbody.MoveRotation(rot);
            }
            else
            {
                transform.position = pos;
                transform.rotation = rot;
            }

            _targetpos = pos;
            _lastAppliedPosition = Position; // Update last applied position
        }
#endif

    }
}
